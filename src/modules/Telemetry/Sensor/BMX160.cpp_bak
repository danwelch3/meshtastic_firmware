#include "BMX160.h"

BMX160::BMX160() {
    devAddr = BMI160_I2C_ADDR;
}
BMX160::BMX160(uint8_t address) {
    devAddr = address;
}

int8_t bmi160read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t count) {
    Serial.print("BMI_TEST ");
    Serial.print(dev_addr, HEX);
    Serial.print(", ");
    Serial.print(reg_addr, HEX);
    Serial.print(", ");
    bool rslt = I2Cdev::readBytes(dev_addr, reg_addr, count, reg_data);

    for (int i=0; i<count; i++) {
        Serial.print(reg_data[i], HEX);
        Serial.print(",");
    }
    Serial.print("\n");

    return (rslt) ? BMI160_OK : BMI160_E_COM_FAIL;
}
int8_t bmi160write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t count) {
    bool rslt = I2Cdev::writeBytes(dev_addr, reg_addr, count, reg_data);
    Serial.print("BMI_write ");
    Serial.print(dev_addr, HEX);
    Serial.print(", ");
    Serial.print(reg_addr, HEX);
    Serial.print(", ");
    for (int i=0; i<count; i++) {
        Serial.print(reg_data[i], HEX);
        Serial.print(",");
    }
    Serial.print("\n");
    return (rslt) ? BMI160_OK : BMI160_E_COM_FAIL;
}
void bmi160delay_ms(uint32_t delay_ms) {
    delay(delay_ms);
}
int8_t bmm150read(uint8_t reg_addr, uint8_t *reg_data, uint32_t length, void *intf_ptr) {
    Serial.print("BMM_TEST ");
    Serial.print(reg_addr, HEX);
    Serial.print(" -> ");
    // bool rslt = I2Cdev::readBytes(BMI160_I2C_ADDR, reg_addr, length, reg_data);
    // return (rslt) ? 0 : 1;
    int rslt = bmi160_aux_read(reg_addr, reg_data, length, (struct bmi160_dev*)(intf_ptr));

    for (int i=0; i<length; i++) {
        Serial.print(reg_data[i], BIN);
        Serial.print(",");
    }
    Serial.print("\n");

    return rslt;
}
int8_t bmm150write(uint8_t reg_addr, const uint8_t *reg_data, uint32_t length, void *intf_ptr) {
    // Serial.print("BMM_TEST ");
    // Serial.print(BMI160_I2C_ADDR, HEX);
    // Serial.print(" ");
    // Serial.print(reg_addr, HEX);
    // Serial.print(" ");
    // Serial.println(length);
    // bool rslt = I2Cdev::writeBytes(BMI160_I2C_ADDR, reg_addr, length, (uint8_t*)reg_data);
    // return (rslt) ? 0 : 1;
    return bmi160_aux_write(reg_addr, (uint8_t*)reg_data, length, (struct bmi160_dev*)(intf_ptr));
}
void bmm150delay_us(uint32_t period, void *intf_ptr) {
    delayMicroseconds(period);
}

void BMX160::initialize(uint8_t address) {
    devAddr = address;
    initialize();
}
void BMX160::initialize() {
    bmi160dev.id = devAddr;
    bmi160dev.intf = BMI160_I2C_INTF;
    bmi160dev.read = bmi160read;
    bmi160dev.write = bmi160write;
    bmi160dev.delay_ms = bmi160delay_ms;

    bmm150dev.intf_ptr = &bmi160dev;
    bmm150dev.read = bmm150read;
    bmm150dev.write = bmm150write;
    bmm150dev.delay_us = bmm150delay_us;
    bmm150dev.intf = BMM150_I2C_INTF;

    /* Select the Output data rate, range of accelerometer sensor */
    bmi160dev.accel_cfg.odr = BMI160_ACCEL_ODR_100HZ;
    bmi160dev.accel_cfg.range = BMI160_ACCEL_RANGE_4G;
    bmi160dev.accel_cfg.bw = BMI160_ACCEL_BW_NORMAL_AVG4;

    /* Select the power mode of accelerometer sensor */
    bmi160dev.accel_cfg.power = BMI160_ACCEL_NORMAL_MODE;

    /* Select the Output data rate, range of Gyroscope sensor */
    bmi160dev.gyro_cfg.odr = BMI160_GYRO_ODR_100HZ;
    bmi160dev.gyro_cfg.range = BMI160_GYRO_RANGE_500_DPS;
    bmi160dev.gyro_cfg.bw = BMI160_GYRO_BW_NORMAL_MODE;

    /* Select the power mode of Gyroscope sensor */
    bmi160dev.gyro_cfg.power = BMI160_GYRO_NORMAL_MODE;

    // Configure the BMI160's iterface to the BMM150
    bmi160dev.aux_cfg.aux_i2c_addr = bmi160dev.id;
    bmi160dev.aux_cfg.aux_sensor_enable = BMI160_ENABLE;
    bmi160dev.aux_cfg.manual_enable = BMI160_ENABLE;
    bmi160dev.aux_cfg.aux_rd_burst_len = BMI160_AUX_READ_LEN_2;

    // Initialize BMI160 Accelerometer and Gyroscope
    int rslt = 0;
    rslt = bmi160_init(&bmi160dev);
    Serial.print("BMI INIT = ");
    Serial.println(rslt);

    rslt = bmi160_aux_init(&bmi160dev);
    Serial.print("BMI AUX INIT = ");
    Serial.println(rslt);

    /* Set the sensor configuration */
    bmi160_set_sens_conf(&bmi160dev);

    // Initialize BMM150 Magnetometer
    bmm150dev.intf = BMM150_I2C_INTF;
    bmm150_init(&bmm150dev);
    // Serial.print("BMM150 INIT = ");
    // Serial.println(rslt);
    // uint8_t rslt = bmm150_perform_self_test(0, &bmm150dev);
    // Serial.print("BMM150 TEST = ");
    // Serial.println(rslt);

    bmm150settings.pwr_mode = BMM150_POWERMODE_NORMAL;
    bmm150_set_op_mode(&bmm150settings, &bmm150dev);

    // I2Cdev::writeByte(devAddr, 0x4C, 0x80);
    // delay(50);
    // I2Cdev::writeByte(devAddr, 0x4F, 0x01);
    // I2Cdev::writeByte(devAddr, 0x4E, 0x4B);
    // I2Cdev::writeByte(devAddr, 0x4F, 0x04);
    // I2Cdev::writeByte(devAddr, 0x4E, 0x51);
    // I2Cdev::writeByte(devAddr, 0x4F, 0x0E);
    // I2Cdev::writeByte(devAddr, 0x4E, 0x52);
    // I2Cdev::writeByte(devAddr, 0x4F, 0x02);
    // I2Cdev::writeByte(devAddr, 0x4E, 0x4C);
    // I2Cdev::writeByte(devAddr, 0x4D, 0x42);
    // I2Cdev::writeByte(devAddr, 0x44, 0x08);
    // I2Cdev::writeByte(devAddr, 0x4C, 0x03);
    // delay(50);

    // bmm150_mag.x = 0;
    // bmm150_mag.y = 0;
    // bmm150_mag.z = 0;
}


uint8_t BMX160::getDeviceID() {
    I2Cdev::readByte(devAddr, BMI160_CHIP_ID_ADDR, buffer);
    return buffer[0];
}

bool BMX160::testConnection() {
    uint8_t deviceId = getDeviceID();
    if (deviceId == 0xD8) {
        return true;
    } else {
        Serial.print("BMX160 ID Failed: ");
        Serial.println(deviceId);

        return false;
    }
}

void BMX160::calibrateMag() {
    int N = 1000;

    Serial.print("Collecting ");
    Serial.print(N);
    Serial.println(" points for magnetometer calibration, 3/second");
    Serial.println("TURN SENSOR VERY SLOWLY AND CAREFULLY IN 3D");
    Serial.println("Starting in 5 seconds...");
    delay(5000);

    for (int i = 0; i < N; i++)
    {

        bmm150_read_mag_data(&bmm150_mag, &bmm150dev);

        mx = bmm150_mag.x;
        my = bmm150_mag.y;
        mz = bmm150_mag.z;

        // I2Cdev::readBytes(devAddr, 0x04, 6, buffer_m);

        // mx = ((int16_t)(buffer_m[1]) << 8) | buffer_m[0];
        // my = ((int16_t)(buffer_m[3]) << 8) | buffer_m[2];
        // mz = ((int16_t)(buffer_m[5]) << 8) | buffer_m[4];

        if (mx >= mx_max)mx_max = mx;
        if (my >= my_max)my_max = my; //find max value
        if (mz >= mz_max)mz_max = mz;

        if (mx <= mx_min)mx_min = mx;
        if (my <= my_min)my_min = my; //find min value
        if (mz <= mz_min)mz_min = mz;

        delay(50);

        Serial.print(mx);
        Serial.print(",");
        Serial.print(my);
        Serial.print(",");
        Serial.print(mz);
        Serial.print("\n");

        // bmi160_get_sensor_data((BMI160_ACCEL_SEL | BMI160_GYRO_SEL), &bmi160_accel, &bmi160_gyro, &bmi160dev);

        // Serial.print(bmi160_accel.x);
        // Serial.print(",");
        // Serial.print(bmi160_accel.y);
        // Serial.print(",");
        // Serial.print(bmi160_accel.z);
        // Serial.print("\n");

        // I2Cdev::readBytes(devAddr, 0x12, 6, buffer_m);
        // ax = ((int16_t)(buffer_m[1]) << 8) | buffer_m[0];
        // ay = ((int16_t)(buffer_m[3]) << 8) | buffer_m[2];
        // az = ((int16_t)(buffer_m[5]) << 8) | buffer_m[4];

        // Serial.print(ax);
        // Serial.print(",");
        // Serial.print(ay);
        // Serial.print(",");
        // Serial.print(az);
        // Serial.print("\n");
    }

    mx_centre = (mx_max + mx_min) / 2;
    my_centre = (my_max + my_min) / 2;
    mz_centre = (mz_max + mz_min) / 2;
    Serial.print("Done. ");
    Serial.print("Mag Center X=");
    Serial.print(mx_centre);
    Serial.print(" Y=");
    Serial.print(my_centre);
    Serial.print(" Z=");
    Serial.println(mz_centre);
}

void BMX160::update() {
    // Read accel and gyro data
    bmi160_get_sensor_data((BMI160_ACCEL_SEL | BMI160_GYRO_SEL), &bmi160_accel, &bmi160_gyro, &bmi160dev);

    Axyz[0] = (double) bmi160_accel.x;
    Axyz[1] = (double) bmi160_accel.y;
    Axyz[2] = (double) bmi160_accel.z;
    
    Gxyz[0] = (double) bmi160_gyro.x;
    Gxyz[1] = (double) bmi160_gyro.y;
    Gxyz[2] = (double) bmi160_gyro.z;

    // Read mag data
    bmm150_read_mag_data(&bmm150_mag, &bmm150dev);

    Mxyz[0] = (double) bmm150_mag.x;
    Mxyz[1] = (double) bmm150_mag.y;
    Mxyz[2] = (double) bmm150_mag.z;

    // apply compass calibration
    Mxyz[0] = Mxyz[0] - mx_centre;
    Mxyz[1] = Mxyz[1] - my_centre;
    Mxyz[2] = Mxyz[2] - mz_centre;
}

float BMX160::getHeading()
{
    float heading = 180 * atan2(Mxyz[1], Mxyz[0]) / PI;
    if (heading < 0) heading += 360;

    return heading;
}

float BMX160::getTiltHeading()
{
    float pitch = asin(-Axyz[0]);
    float roll = asin(Axyz[1] / cos(pitch));

    float xh = Mxyz[0] * cos(pitch) + Mxyz[2] * sin(pitch);
    float yh = Mxyz[0] * sin(roll) * sin(pitch) + Mxyz[1] * cos(roll) - Mxyz[2] * sin(roll) * cos(pitch);
    float zh = -Mxyz[0] * cos(roll) * sin(pitch) + Mxyz[1] * sin(roll) + Mxyz[2] * cos(roll) * cos(pitch);
    float tiltheading = 180 * atan2(yh, xh) / PI;
    if (yh < 0)    tiltheading += 360;

    return tiltheading;
}